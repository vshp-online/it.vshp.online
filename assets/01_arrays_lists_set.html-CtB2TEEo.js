import{_ as a,c as t,a as i,o as r}from"./app-TjX1P9Ye.js";const n={};function p(l,e){return r(),t("div",null,[...e[0]||(e[0]=[i('<h1 id="_01-—-массивы-обычные-динамические-связные-списки-одно-двусвязные-множества-set" tabindex="-1"><a class="header-anchor" href="#_01-—-массивы-обычные-динамические-связные-списки-одно-двусвязные-множества-set"><span>01 — Массивы (обычные/динамические), связные списки (одно-/двусвязные), множества (Set)</span></a></h1><div class="hint-container warning"><p class="hint-container-title">Примечание</p><p>Раздел находится в процессе наполнения!</p></div><h2 id="введение" tabindex="-1"><a class="header-anchor" href="#введение"><span>Введение</span></a></h2><p>Структура данных — это способ организации информации для более эффективного использования. В программировании структурой обычно называют набор данных, связанных определённым образом. Например, массив — это структура.<br> Со структурой можно работать: добавлять данные, извлекать их и обрабатывать, например изменять, анализировать, сортировать. Для каждой структуры данных — свои алгоритмы. Работа программиста — правильно выбирать уже написанные готовые либо писать свои.</p><p>Главное свойство структур данных в том, что у любой единицы данных должно быть чёткое место, по которому её можно найти. Как определяется это место и как происходит поиск, зависит от конкретной структуры.</p><p>Характеристики структур данных следующие:</p><ul><li>Данные в памяти представлены определённым образом, который однозначно позволяет определить структуру.</li><li>Чаще всего внутрь структуры можно добавить элемент или извлечь оттуда. Это свойство не постоянное — бывают структуры, которые нельзя изменять после создания.</li><li>Существуют алгоритмы, которые позволяют взаимодействовать с этой структурой.</li></ul><p>При этом данных необязательно должно быть много. Массив из одного элемента — уже структура данных.</p><p>Структуры нужны, чтобы упорядочивать, искать, анализировать и использовать данные с применением алгоритмов программирования.</p><p>Фактически использование структур данных в программировании начинается ещё с задания переменной. Формат переменной — определённая структура данных, так как в память переменная записывается конкретным способом. Но на практике программисты работают с другими структурами, которые объединяют в себе разные переменные и типы данных. Далее приведем описание и классификацию основных структур данных, чтобы было удобнее в них разобраться.</p><h2 id="массив-array" tabindex="-1"><a class="header-anchor" href="#массив-array"><span>Массив (Array)</span></a></h2><p>Одна из самых простых структур данных, которая встречается чаще всего. Именно на массивах основаны многие другие структуры данных: списки, стеки, очереди.</p><p>Для простоты восприятия можно считать, что массив — это таблица. Каждый его элемент имеет индекс — «адрес», по которому этот элемент можно извлечь. В большинстве языков программирования индексы начинаются с нуля. То есть первый элемент массива имеет индекс не <code>[1]</code>, а <code>[0]</code>. Данные в массиве можно просматривать, сортировать и изменять с помощью специальных операций.</p><p>Массивы бывают двух видов:</p><ul><li><p><strong>Одномерные</strong><br> У каждого элемента только один индекс. Можно представить это как строку с данными, где одного номера достаточно, чтобы чётко определить положение каждой переменной.</p></li><li><p><strong>Многомерные</strong><br> У каждого элемента два или больше индексов. По сути, это комбинация из нескольких одномерных массивов, то есть вложенная структура.</p></li></ul><figure><img src="https://avatars.mds.yandex.net/get-lpc/1531919/ed6b58ba-05ac-4b61-90cc-00aebd47bc3d/width_1920_q80" alt="Виды массивов" tabindex="0" loading="lazy"><figcaption>Виды массивов</figcaption></figure><p>Основное отличие между одномерным и многомерным массивом ― их размерность и способ организации данных. Одномерный массив ― простая линейная структура данных, многомерный ― более сложная структура данных с несколькими измерениями</p><p>Как применяют массивы:</p><ul><li>В качестве блоков для более сложных структур данных. Массивы предусмотрены в синтаксисе большинства языков программирования, и на их основе удобно строить другие структуры.</li><li>Для хранения несложных данных небольших объёмов.</li><li>Для сортировки данных.</li></ul><h3 id="динамическии-массив-dynamic-array" tabindex="-1"><a class="header-anchor" href="#динамическии-массив-dynamic-array"><span>Динамический массив (Dynamic array)</span></a></h3><p>В классическом массиве размер задан заранее — мы точно знаем, сколько в нём индексов. А динамический массив — это тот, у которого размер может изменяться. При его создании задаётся максимальная величина и количество заполненных элементов. При добавлении новых элементов они сначала заполняются до максимальной величины, а при превышении сразу создаётся новый массив, с большей максимальной величиной.</p><p>Элементы в динамический массив можно добавлять без ограничений и куда угодно. Однако, если добавлять их в середину, остальные придётся сдвигать, что занимает много времени. Поэтому лучше всего динамический массив работает при добавлении элементов в конце.</p><p>Как применяют динамические массивы:</p><ul><li>В качестве блоков для структур данных.</li><li>Для хранения неопределённого количества элементов.</li></ul><h2 id="связныи-список-linked-list" tabindex="-1"><a class="header-anchor" href="#связныи-список-linked-list"><span>Связный список (Linked list)</span></a></h2><p>Ещё одна базовая структура данных, которую, как и массивы, используют для реализации других структур. Связный список — это группа из узлов. В каждом узле содержатся:</p><ul><li>Данные.</li><li>Указатель или ссылка на следующий узел.</li><li>В некоторых списках — ещё и ссылка на предыдущий узел.</li></ul><p>В итоге получается список, у которого есть чёткая последовательность элементов. При этом сами элементы более разрозненны, чем в массиве, поскольку хранятся отдельно. Быстро перемещаться между элементами списка помогают указатели.</p><figure><img src="https://avatars.mds.yandex.net/get-lpc/403342/d92655b4-2807-4b81-8608-533a836b120f/width_1920_q80" alt="Структура связного списка" tabindex="0" loading="lazy"><figcaption>Структура связного списка</figcaption></figure><p>Как применяют связные списки:</p><ul><li>Для построения более сложных структур данных.</li><li>Для реализации файловых систем.</li><li>Для формирования хэш-таблиц.</li><li>Для выделения памяти в динамических структурах данных.</li></ul><h2 id="множество-set" tabindex="-1"><a class="header-anchor" href="#множество-set"><span>Множество (Set)</span></a></h2><p>В отличие от предыдущих базовых структур, во множестве данные не упорядочены. Они хранятся группой, их нельзя структурировать и в некоторых случаях нельзя сортировать. Зато с ними можно работать как с классическими математическими множествами: объединять, искать пересечения, вычислять разность и смотреть, является ли одно множество подмножеством другого.</p><figure><img src="https://avatars.mds.yandex.net/get-lpc/403342/e4f8eeee-6cf0-4389-af4a-340cc0ebff7b/width_1920_q80" alt="Структура множества" tabindex="0" loading="lazy"><figcaption>Структура множества</figcaption></figure><p>Обычно во множество помещают объекты, у которых есть что-то общее. Важны свойства объектов, а их порядок значения не имеет.</p><p>Как применяют множества:</p><ul><li>Для поддержания множества уникальных элементов.</li><li>Для хранения данных, которые не нужно сортировать.</li><li>Для сравнения, объединения наборов данных и других операций с ними.</li></ul>',37)])])}const c=a(n,[["render",p]]),d=JSON.parse('{"path":"/disciplines/up01/lectures/01_arrays_lists_set.html","title":"01 — Массивы (обычные/динамические), связные списки (одно-/двусвязные), множества (Set)","lang":"ru-RU","frontmatter":{"description":"01 — Массивы (обычные/динамические), связные списки (одно-/двусвязные), множества (Set) Примечание Раздел находится в процессе наполнения! Введение Структура данных — это способ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"01 — Массивы (обычные/динамические), связные списки (одно-/двусвязные), множества (Set)\\",\\"image\\":[\\"https://avatars.mds.yandex.net/get-lpc/1531919/ed6b58ba-05ac-4b61-90cc-00aebd47bc3d/width_1920_q80\\",\\"https://avatars.mds.yandex.net/get-lpc/403342/d92655b4-2807-4b81-8608-533a836b120f/width_1920_q80\\",\\"https://avatars.mds.yandex.net/get-lpc/403342/e4f8eeee-6cf0-4389-af4a-340cc0ebff7b/width_1920_q80\\"],\\"dateModified\\":\\"2025-10-26T22:04:25.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://it.vshp.online/disciplines/up01/lectures/01_arrays_lists_set.html"}],["meta",{"property":"og:site_name","content":"Кафедра ИТ"}],["meta",{"property":"og:title","content":"01 — Массивы (обычные/динамические), связные списки (одно-/двусвязные), множества (Set)"}],["meta",{"property":"og:description","content":"01 — Массивы (обычные/динамические), связные списки (одно-/двусвязные), множества (Set) Примечание Раздел находится в процессе наполнения! Введение Структура данных — это способ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://avatars.mds.yandex.net/get-lpc/1531919/ed6b58ba-05ac-4b61-90cc-00aebd47bc3d/width_1920_q80"}],["meta",{"property":"og:locale","content":"ru-RU"}],["meta",{"property":"og:updated_time","content":"2025-10-26T22:04:25.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-26T22:04:25.000Z"}]]},"git":{"updatedTime":1761516265000,"contributors":[{"name":"PAVEL TKACHEV","username":"","email":"phoenixweiss@ya.ru","commits":1}],"changelog":[{"hash":"b08244123ec11f0f24810ca659f86792f7a03172","time":1761516265000,"email":"phoenixweiss@ya.ru","author":"PAVEL TKACHEV","message":"Update <a href=\\"http://index.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">index.md</a>, <a href=\\"http://index.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">index.md</a>, 01_arrays_lists_set.md, and 5 more files"}]},"autoDesc":true,"filePathRelative":"disciplines/up01/lectures/01_arrays_lists_set.md"}');export{c as comp,d as data};
