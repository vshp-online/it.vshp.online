import{_ as e,c as p,a,b as t,d as o,w as c,r as l,o as i,e as r}from"./app-CdTySVJ0.js";const d={};function u(m,s){const n=l("RouteLink");return i(),p("div",null,[s[1]||(s[1]=a('<div class="hint-container warning"><p class="hint-container-title">Примечание</p><p><strong>ЭТО АРХИВНАЯ ВЕРСИЯ КУРСА!</strong></p><p>Материалы предназначаются для пересдающих дисциплину &quot;ОП.04 - Основы алгоритмизации и программирования&quot; в соответствии с учебными планами СПО годов набора <strong>ДО 2023-го</strong>.</p><p>Материалы были перенесены со старого сайта с минимальной доработкой, поэтому не все возможности курса могут работать как ожидается, где-то может слететь форматирование.</p><p><strong>Домашние задания в рамках курса проверяться не будут!</strong></p></div><h1 id="оп-04-15-итерация-и-итеративныи-процесс-случаиность-в-программировании-проблемы-точности-вычислении" tabindex="-1"><a class="header-anchor" href="#оп-04-15-итерация-и-итеративныи-процесс-случаиность-в-программировании-проблемы-точности-вычислении"><span>ОП.04 - 15 - Итерация и итеративный процесс. Случайность в программировании. Проблемы точности вычислений</span></a></h1>',2)),t("p",null,[o(n,{to:"/disciplines/op04/includes/_html_example.html"},{default:c(()=>[...s[0]||(s[0]=[r("Код примера для практической работы",-1)])]),_:1})]),s[2]||(s[2]=a(`<h2 id="итерация-и-итеративныи-процесс" tabindex="-1"><a class="header-anchor" href="#итерация-и-итеративныи-процесс"><span>Итерация и итеративный процесс</span></a></h2><p>Технология итерационной разработки характеризует жизненный цикл проекта программного обеспечения, включающий несколько итераций. Итерация состоит из примерно последовательного набора задач, выбранных из всех без исключения разделов разработки программного обеспечения. Часто такой подход называют <em>итеративным подходом</em>.</p><blockquote><p><strong>Итеративный подход</strong> (англ. iteration - «повторение») в разработке программного обеспечения — это выполнение работ с непрерывным анализом полученных результатов и корректировкой последующих этапов работы. Проект при этом подходе в каждой фазе развития проходит повторяющийся цикл: Планирование — Реализация — Проверка — Корректировка (англ. plan-do-check-act cycle / PDCA).</p></blockquote><figure><img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Iterative_development_model.svg" alt="PDCA | block" tabindex="0" loading="lazy"><figcaption>PDCA | block</figcaption></figure><blockquote><p>PDCA (англ. «Plan-Do-Check-Act» — планирование-действие-проверка-корректировка) — методология принятия решения, используемая в управлении качеством.Также известен как цикл Деминга, цикл Шухарта, принцип Деминга-Шухарта (Деминг говорил PDSA (Plan-Do-Study-Act); Шухарт — Plan-Do-Check-Act).</p></blockquote><hr><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/73/W._Edwards_Deming.jpg" alt="Уильям Эдвардс Деминг | sm" loading="lazy"><br><em>Уильям Эдвардс Деминг</em></p><p>Деминг, Уильям Эдвардс; Эдвард Деминг (англ. William Edwards Deming, 14 октября 1900 — 20 декабря 1993) — американский учёный, статистик и консультант по менеджменту. Наибольшую известность Деминг приобрел, благодаря доработанному им циклу Шухарта, который теперь весь мир называет циклом Шухарта — Деминга (PDCA).</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/ba/WAShewhart.jpg" alt="Уолтер Эндрю Шухарт | sm" loading="lazy"><br><em>Уолтер Эндрю Шухарт</em></p><p>Уолтер Эндрю Шухарт (англ. Walter Andrew Shewhart; 18 марта 1891 — 11 марта 1967) — американский учёный и консультант по теории управления качеством.</p><hr><p>Методология PDCA представляет собой алгоритм действий руководителя по управлению процессом и достижению его целей и состоит из:</p><ul><li>планирования — установления целей и процессов, необходимых для достижения целей, планирования работ по достижению целей процесса и удовлетворения потребителя, планирования выделения и распределения необходимых ресурсов;</li><li>выполнения — выполнение запланированных работ;</li><li>проверки — сбора информации и контроль результата на основе ключевых показателей эффективности (KPI), получившегося в ходе выполнения процесса, выявления и анализа отклонений, установления причин отклонений;</li><li>воздействия (управления, корректировки) — принятия мер по устранению причин отклонений от запланированного результата, изменений в планировании и распределении ресурсов.</li></ul><p>В практической деятельности цикл PDCA применяется многократно с различной периодичностью. При выполнении основной деятельности цикл PDCA применяется с периодичностью циклов отчетности и планирования. При выполнении корректирующих действий длительность PDCA может быть меньше или больше длительности циклов отчетности и планирования и устанавливается в зависимости от характера, объема, длительности и содержания мероприятий по устранению причин отклонения.</p><h3 id="что-такое-итерационная-разработка" tabindex="-1"><a class="header-anchor" href="#что-такое-итерационная-разработка"><span>Что такое итерационная разработка?</span></a></h3><blockquote><p><strong>Итеративный процесс</strong> (также <strong>итеративный подход</strong> или <strong>итерационная разработка</strong>) в программировании — это подход при котором разработка программного продукта делится на четкие определенные шаги, называемые <strong>итерациями</strong>. Конкретный набор шагов зависит от проекта и используемой методологии разработки.</p></blockquote><p>Проект, в котором применяется итерационная разработка, имеет жизненный цикл, состоящий из нескольких итераций. Итерация включает приблизительно последовательный набор задач бизнес-моделирования, требований, анализа и проектирования, реализации, тестирования и развертывания в различных пропорциях, в зависимости от расположения итерации в цикле разработки. Итерации на начальном этапе и этапе уточнения фокусируются на управлении, требованиях и проектировании; итерации на этапе построения фокусируются на проектировании, реализации и тестировании; а итерации на этапе внедрения фокусируются на тестировании и развертывании.</p><p>Преимущества итеративного подхода в разработке:</p><ul><li>снижение воздействия серьёзных рисков на ранних стадиях проекта, что ведет к минимизации затрат на их устранение;</li><li>организация эффективной обратной связи проектной команды с потребителем (а также заказчиками, стейкхолдерами) и создание продукта, реально отвечающего его потребностям;</li><li>акцент усилий на наиболее важные и критичные направления проекта;</li><li>непрерывное итеративное тестирование, позволяющее оценить успешность всего проекта в целом;</li><li>раннее обнаружение конфликтов между требованиями, моделями и реализацией проекта;</li><li>более равномерная загрузка участников проекта;</li><li>эффективное использование накопленного опыта;</li><li>реальная оценка текущего состояния проекта и, как следствие, большая уверенность заказчиков и непосредственных участников в его успешном завершении;</li><li>затраты распределяются по всему проекту, а не группируются в его конце.</li></ul><p>В начальном проекте по отношению к его ключевым требованиям с большой вероятностью будут содержаться ошибки. Позднее обнаружение дефектов проекта приводит к дорогостоящим затратам и, в некоторых случаях, даже к прекращению проекта. Любой проект влечет за собой определенные риски. Чем раньше в жизненном цикле можно проверить отсутствие рисков, тем более точно можно выполнять планирование. Многие риски не удается обнаружить до тех пор, пока не будет предпринята попытка интеграции системы. Невозможно предугадать все риски, независимо от опыта коллектива разработчиков.</p><figure><img src="http://dit.isuct.ru/Publish_RUP/core.base_rup/guidances/supportingmaterials/resources/risk_wf.gif" alt="Схема рисков | block" tabindex="0" loading="lazy"><figcaption>Схема рисков | block</figcaption></figure><h3 id="пять-шагов-итеративного-процесса" tabindex="-1"><a class="header-anchor" href="#пять-шагов-итеративного-процесса"><span>Пять шагов итеративного процесса</span></a></h3><p>Итеративный процесс может быть полезен на протяжении всего жизненного цикла проекта. В итеративном процессе ваши цели и требования принимаются в качестве отправной точки проекта. После этого команда будет производить тестирование, разработку прототипов и итерацию для достижения максимально эффективного результата. Для этого необходимо соблюдать нижеследующие правила.</p><ol><li><strong>Составление плана и требований</strong></li></ol><p>На этом шаге итеративного процесса определяется план проекта, а также выполняется согласование с общими целями проекта. Именно в этой точке проекта формулируются все самые значительные требования, от выполнения которых зависит успешность реализации проекта. Без этого действия итерация может не достичь своей цели.</p><ol start="2"><li><strong>Анализ и проектирование</strong></li></ol><p>На этом шаге вы с вашей командой занимаетесь бизнес-потребностями и техническими требованиями своего проекта. Если на первом шаге определялись цели, то на втором вы продумываете проект, который в конечном счёте поможет достичь этих целей.</p><ol start="3"><li><strong>Реализация</strong></li></ol><p>На третьем шаге создаётся первая итерация реализации проекта. Данная итерация основывается на результатах анализа и проектирования и помогает достичь конечной цели проекта. Уровень детализации и время, затрачиваемое на эту итерацию, зависит от проекта.</p><ol start="4"><li><strong>Тестирование</strong></li></ol><p>После получения первой итерации производится её тестирование наиболее подходящим способом.</p><ol start="5"><li><strong>Рассмотрение и оценка результата</strong></li></ol><p>После тестирования производится оценка успешности итерации и согласование необходимых изменений. Достигает ли эта итерация цели проекта? Почему? Если требуются изменения, можно возобновить итеративный процесс и начать со второго шага, создав следующую итерацию. Помните, что первоначальный план и цели должны быть одинаковыми для всех итераций. Продолжайте работу на основе предыдущей итерации, пока не добьётесь желаемого результата.</p><p>Итеративный процесс может длиться неделями или месяцами в зависимости от количества итераций, через которые вам приходится пройти. Если всякий раз при повторном запуске итеративного процесса итерация будет сосредоточена на целях проекта, вы сможете всегда держать свои ориентиры в поле зрения.</p><h2 id="случаиность-в-программировании" tabindex="-1"><a class="header-anchor" href="#случаиность-в-программировании"><span>Случайность в программировании</span></a></h2><p>В программном обеспечении, да и в технике в целом существует необходимость в воспроизводимой случайности: числа и картинки, которые кажутся случайными, на самом деле сгенерированы определённым алгоритмом. Это называется <em>псевдослучайностью</em>. Генерация случайных чисел имеет множество приложений в области информатики и особенно важна для криптографии.</p><p>Определение того, что именно является случайностью, может быть довольно сложной задачей. Существуют тесты (например, колмогоровская сложность), которые могут дать вам точное значение того, насколько случайна та или иная последовательность.</p><p>Часто требуется не просто одно число, а несколько случайных чисел, генерируемых непрерывно. Следовательно, учитывая начальное значение, нам нужно создать другие случайные числа. Это начальное значение называется <em>семенем</em> (от англ. <em>seed</em>). Один из наиболее популярных подходов заключается в том, чтобы применить какую-то сложную математическую формулу к семени, а затем исказить её настолько, что число на выходе будет казаться непредсказуемым, а после взять его как семя для следующей итерации. Вопрос только в том, как должна выглядеть эта функция искажения.</p><p>Функция искажения будет принимать одно значение, а возвращать другое. Назовём её <code>rnd()</code>.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">rnd</span><span class="token punctuation">(</span>Input<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Output</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Начнём с того, что <code>rnd()</code> - это простая функция, которая всего лишь прибавляет единицу.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">rnd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Если значение нашего семени 1, то <code>rnd()</code> создаст ряд <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>... Выглядит совсем не случайно, но мы дойдём до этого. Пусть теперь <code>rnd()</code> добавляет константу вместо 1.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">rnd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> x <span class="token operator">+</span> c</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Если <code>с</code> равняется, например, <code>7</code>, то мы получим ряд <code>1</code>, <code>8</code>, <code>15</code>, <code>22</code>... Всё ещё не то. Очевидно, что мы упускаем то, что числа не должны только увеличиваться, они должны быть разбросаны по какому-то диапазону. Нам нужно, чтобы наша последовательность возвращалась в начало - круг из чисел!</p><p>Посмотрим на циферблат часов: наш ряд начинается с <code>1</code> и идёт по кругу до <code>12</code>. Но поскольку мы работаем с компьютером, пусть вместо <code>12</code> будет <code>0</code>.</p><figure><img src="https://media.proglib.io/wp-uploads/2017/11/1-4g7Sl3v-4NtPkbduzKoRrw-300x300.png" alt="Циферблат | block" tabindex="0" loading="lazy"><figcaption>Циферблат | block</figcaption></figure><p>Теперь начиная с <code>1</code> снова будем прибавлять <code>7</code>. Прогресс! Мы видим, что после <code>12</code> наш ряд начинает повторяться, независимо от того, с какого числа начать. Здесь мы получаем очень важно свойство: если наш цикл состоит из <code>n</code> элементов, то максимальное число элементов, которые мы можем получить перед тем, как они начнут повторяться это <code>n</code>.</p><p>Теперь давайте переделаем функцию <code>rnd()</code> так, чтобы она соответствовала нашей логике. Ограничить длину цикла можно с помощью оператора модуля или оператора остатка от деления.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">rnd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token operator">%</span> m</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>На этом этапе вы можете заметить, что некоторые числа не подходят для <code>c</code>. Если <code>c = 4</code>, и мы начали с <code>1</code>, наша последовательность была бы <code>1</code>, <code>5</code>, <code>9</code>, <code>1</code>, <code>5</code>, <code>9</code>, <code>1</code>, <code>5</code>, <code>9</code>... что нам конечно же не подходит, потому что эта последовательность абсолютно не случайная. Становится понятно, что числа, которые мы выбираем для длины цикла и длины прыжка должны быть связаны особым образом.</p><p>Если вы попробуете несколько разных значений, то сможете увидеть одно свойство: <code>m</code> и <code>с</code> должны быть взаимно простыми.</p><p>До сих пор мы делали &quot;прыжки&quot; за счёт добавления, но что если использовать умножение? Умножим <code>х</code> на константу <code>a</code>.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">rnd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ax <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token operator">%</span> m</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Свойства, которым должно подчиняться <code>а</code>, чтобы образовался полный цикл, немного более специфичны. Чтобы создать верный цикл:</p><ul><li><code>(а - 1)</code> должно делиться на все простые множители <code>m</code></li><li><code>(а - 1)</code> должно делиться на <code>4</code>, если <code>m</code> делится на <code>4</code></li></ul><p>Эти свойства вместе с правилом, что <code>m</code> и <code>с</code> должны быть взаимно простыми составляют теорему Халла-Добелла. Мы не будем рассматривать её доказательство, но если бы вы взяли кучу разных значений для разных констант, то могли бы прийти к тому же выводу.</p><p>Настало время поговорить о самом интересном: выборе первоначального семени. Мы могли бы сделать его константой. Это может пригодиться в тех случаях, когда вам нужны случайные числа, но при этом нужно, чтобы при каждом запуске программы они были одинаковые. Например, создание одинаковой карты для каждой игры.</p><p>Еще один способ - это получать семя из нового источника каждый раз при запуске программы, как в системных часах. Это пригодится в случае, когда нужно общее случайное число, как в программе с бросанием кубика.</p><p>Когда мы применяем функцию к её результату несколько раз, мы получаем рекуррентное соотношение. Давайте запишем нашу формулу с использованием рекурсии:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token function">x</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> <span class="token function">x</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token operator">%</span> m</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Где начальное значение <code>х</code> - это семя, <code>а</code> - множитель, <code>с</code> - константа, <code>m</code> - оператор остатка от деления.</p><p>То, что мы сделали, называется <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%BD%D0%B3%D1%80%D1%83%D1%8D%D0%BD%D1%82%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4" target="_blank" rel="noopener noreferrer">линейным конгруэнтным методом</a>. Он очень часто используется, потому что он прост в реализации и вычисления выполняются быстро. В разных языках программирования реализация линейного конгруэнтного метода отличается, то есть меняются значения констант. Существуют и другие алгоритмы генерации случайных чисел, но линейный конгруэнтный метод считается классическим и лёгким для понимания.</p><p>В JavaScript встроен объект <code>Math</code>, который содержит различные математические функции и константы. И функция для генерации псевдослучайных чисел в нем уже реализована посредством <code>Math.random()</code>, которая в качестве семени использует значение таймштампа с точностью до миллисекунды на момент вызова. При вызове <code>Math.random()</code> возвращает псевдослучайное число в диапазоне от <code>0</code> (включительно) до <code>1</code> (но не включая <code>1</code>!).</p><p>Пример:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.1234567894322</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>В виде функции можно вызвать например так:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Следующий пример возвращает случайное число в заданном интервале. Возвращаемое значение не менее (и может быть равно) <code>min</code> и не более (и не равно) <code>max</code>.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">getRandomArbitrary</span><span class="token punctuation">(</span><span class="token parameter">min<span class="token punctuation">,</span> max</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>А вот этот пример возвращает случайное целое число в заданном интервале. Возвращаемое значение не менее <code>min</code> (или следующее целое число, которое больше <code>min</code>, если <code>min</code> не целое) и не более (но не равно) <code>max</code>.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">getRandomInt</span><span class="token punctuation">(</span><span class="token parameter">min<span class="token punctuation">,</span> max</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span> <span class="token comment">//Максимум не включается, минимум включается</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>[!INFO]<br> Одна из часто используемых операций при работе с числами — это округление. В JavaScript есть несколько встроенных функций для работы с округлением:</p><ul><li><code>Math.floor()</code> - Округление в меньшую сторону: <code>3.1</code> становится <code>3</code>, а <code>-1.1</code> — <code>-2</code>.</li><li><code>Math.ceil()</code> - Округление в большую сторону: <code>3.1</code> становится <code>4</code>, а <code>-1.1</code> — <code>-1</code>.</li><li><code>Math.round()</code> - Округление до ближайшего целого: <code>3.1</code> становится <code>3</code>, <code>3.6</code> — <code>4</code>, а <code>-1.1</code> — <code>-1</code>.</li></ul><p>Может показаться заманчивым использовать <code>Math.round()</code> для округления, но это может сделать распределение неравномерным, что может оказаться неприемлемым для ваших нужд.</p></blockquote><p>Функция <code>getRandomInt()</code> выше включает минимальное значение, но не включает максимальное. Но что если вам нужно, чтобы включалось и минимальное, и максимальное значение? Функция <code>getRandomIntInclusive()</code> решает этот вопрос.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">getRandomIntInclusive</span><span class="token punctuation">(</span><span class="token parameter">min<span class="token punctuation">,</span> max</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span> <span class="token comment">//Максимум и минимум включаются</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="проблемы-точности-вычислении" tabindex="-1"><a class="header-anchor" href="#проблемы-точности-вычислении"><span>Проблемы точности вычислений</span></a></h2><p>Существует множество ситуаций, в которых точность округления и точность в вычислениях с плавающей точкой (запятой в стандартах записи чисел в РФ) могут работать для создания неожиданных для программиста результатов.</p><p>Прежде чем продолжить, давайте разберемся с одной маленькой концепцией: как числа представлены в вычислительных целях? Очень маленькие и очень большие числа обычно хранятся в экспоненциальном представлении. Они представлены как:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>число</mtext><mo>×</mo><msup><mtext>основание</mtext><mtext>экспонента</mtext></msup></mrow><annotation encoding="application/x-tex">\\text{число} \\times \\text{основание}^\\text{экспонента} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord cyrillic_fallback">число</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord"><span class="mord text"><span class="mord cyrillic_fallback">основание</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord cyrillic_fallback mtight">экспонента</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>Кроме того, число нормализуется, если оно записано в экспоненциальном представлении с одной ненулевой десятичной цифрой перед десятичной точкой. Например, число 0,0005606 в экспоненциальном представлении и нормализованное будет представлено как:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>5</mn><mo separator="true">,</mo><mn>606</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">5,606 \\times 10^{-4} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">606</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>В информатике принято использовать формулу экспоненциальной записи числа:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><mi>M</mi><mo>×</mo><msup><mi>n</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">N = M \\times n^p </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span></p><p>где:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> — записываемое число;</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> — мантисса;</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> — основание показательной функции;</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> (целое) — порядок;</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">n^{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span> — характеристика числа.</li></ul><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> — это количество значащих цифр, которые не включают нулей, а основание представляет собой используемую базовую систему, которая здесь десятичная <code>(10)</code>. Экспонента представляет собой количество мест, на которое необходимо переместить точку счисления влево или вправо для правильного представления.</p><p>Есть два способа отображения чисел в арифметике с плавающей запятой: одинарная точность и двойная точность. Одинарная точность использует <code>32</code> бита, а двойная точность использует <code>64</code> бита для арифметики с плавающей запятой. В отличие от многих других языков программирования, JavaScript не определяет различные типы числовых типов данных и всегда хранит числа как числа с плавающей запятой двойной точности в соответствии с международным стандартом <a href="https://ru.wikipedia.org/wiki/IEEE_754-2008" target="_blank" rel="noopener noreferrer">IEEE-754</a>.</p><figure><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/c59/db9/e23/c59db9e23ae81295251f732a58d8440e.png" alt="64bit_float | block" tabindex="0" loading="lazy"><figcaption>64bit_float | block</figcaption></figure><p>Для хранения числа используется <code>64</code> бита: <code>52</code> из них используется для хранения цифр, <code>11</code> для хранения положения десятичной точки и <code>1</code> бит отведён на хранение знака.</p><p>Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">1e500</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Infinity</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Наиболее часто встречающаяся ошибка при работе с числами в JavaScript — это потеря точности.</p><p>Посмотрите на это (неверное!) сравнение:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">==</span> <span class="token number">0.3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Да-да, сумма 0.1 и 0.2 не равна 0.3.</p><p>Странно! Что тогда, если не 0.3?</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.30000000000000004</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Ой! Здесь гораздо больше последствий, чем просто некорректное сравнение. Представьте, вы делаете интернет-магазин и посетители формируют заказ из 2-х позиций за <code>$0.10</code> и <code>$0.20</code>. Итоговый заказ будет <code>$0.30000000000000004</code>. Это будет сюрпризом для всех.</p><p>Но почему это происходит?</p><p>Число хранится в памяти в бинарной форме, как последовательность бит — единиц и нулей. Но дроби, такие как <code>0.1</code>, <code>0.2</code>, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.</p><p>Другими словами, что такое <code>0.1</code>? Это единица делённая на десять — <code>1/10</code>, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: <code>1/3</code>, которая становится бесконечной дробью <code>0.33333(3)</code>.</p><p>Деление на <code>10</code> гарантированно хорошо работает в десятичной системе, но деление на <code>3</code> — нет. По той же причине и в двоичной системе счисления, деление на <code>2</code> обязательно сработает, а <code>1/10</code> становится бесконечной дробью.</p><p>В JavaScript нет возможности для хранения точных значений <code>0.1</code> или <code>0.2</code>, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления.</p><p>Числовой формат <em>IEEE-754</em> решает эту проблему путём округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.</p><p>Пример:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">0.1</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.10000000000000000555</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>И когда мы суммируем <code>2</code> числа, их «неточности» тоже суммируются.</p><p>Вот почему <code>0.1 + 0.2</code> — это не совсем <code>0.3</code>.</p><blockquote><p>[!INFO]<br> Справедливости ради заметим, что ошибка в точности вычислений для чисел с плавающей точкой сохраняется в любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl, Ruby.</p></blockquote><p>Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод <code>toFixed(n)</code>:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> sum<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.30</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Помните, что метод <code>toFixed</code> всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части. Также это удобно для форматирования цен в интернет-магазине <code>$0.30</code>. В других случаях можно использовать унарный оператор <code>+</code>, чтобы преобразовать строку в число:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">;</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token operator">+</span>sum<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.3</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Также можно временно умножить число на <code>100</code> (или на большее), чтобы привести его к целому, выполнить математические действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она всё равно появляется при финальном делении:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.3</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token number">0.28</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">0.14</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.4200000000000001</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Таким образом, метод умножения/деления уменьшает погрешность, но полностью её не решает.</p><p>Иногда можно попробовать полностью отказаться от дробей. Например, если мы в нашем интернет-магазине начнём использовать центы вместо долларов. Но что будет, если мы применим скидку <code>30%</code>? На практике у нас не получится полностью избавиться от дроби. Просто используйте округление, чтобы отрезать «хвосты», когда надо.</p><h3 id="забавныи-пример" tabindex="-1"><a class="header-anchor" href="#забавныи-пример"><span>Забавный пример</span></a></h3><p>Попробуйте выполнить его:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token comment">// Привет! Я — число, растущее само по себе!</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">9999999999999999</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// покажет 10000000000000000</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Причина та же — потеря точности. Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».</p><blockquote><p>[!INFO]<br> Другим забавным следствием внутреннего представления чисел является наличие двух нулей: <code>0</code> и <code>-0</code>. Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль. В большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.</p></blockquote><h2 id="что-почитать-по-теме" tabindex="-1"><a class="header-anchor" href="#что-почитать-по-теме"><span>Что почитать по теме</span></a></h2><ul><li><a href="https://ru.wikipedia.org/wiki/%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0" target="_blank" rel="noopener noreferrer">Статья на Википедии - Итеративная разработка</a></li><li><a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB_%D0%94%D0%B5%D0%BC%D0%B8%D0%BD%D0%B3%D0%B0" target="_blank" rel="noopener noreferrer">Статья на Википедии - Цикл Деминга</a></li><li><a href="%D0%AD%D0%BA%D1%81%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C">Статья на Википедии - Экспоненциальная запись</a></li><li><a href="https://proglib.io/p/how-computers-make-random-numbers" target="_blank" rel="noopener noreferrer">Библиотека программиста - Как компьютер генерирует случайные числа</a></li><li><a href="https://learn.javascript.ru/number" target="_blank" rel="noopener noreferrer">Современный учебник JavaScript - Числа</a></li><li><a href="https://www.w3schools.com/js/js_numbers.asp" target="_blank" rel="noopener noreferrer">W3Schools - JavaScript Numbers</a></li><li><a href="https://www.w3schools.com/js/js_random.asp" target="_blank" rel="noopener noreferrer">W3Schools - JavaScript Random</a></li><li><a href="https://0.30000000000000004.com/" target="_blank" rel="noopener noreferrer">Floating Point Math</a></li></ul>`,124))])}const h=e(d,[["render",u]]),g=JSON.parse('{"path":"/disciplines/op04/op04_15.html","title":"ОП.04 - 15 - Итерация и итеративный процесс. Случайность в программировании. Проблемы точности вычислений","lang":"ru-RU","frontmatter":{"description":"Примечание ЭТО АРХИВНАЯ ВЕРСИЯ КУРСА! Материалы предназначаются для пересдающих дисциплину \\"ОП.04 - Основы алгоритмизации и программирования\\" в соответствии с учебными планами С...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ОП.04 - 15 - Итерация и итеративный процесс. Случайность в программировании. Проблемы точности вычислений\\",\\"image\\":[\\"https://upload.wikimedia.org/wikipedia/commons/3/39/Iterative_development_model.svg\\",\\"https://upload.wikimedia.org/wikipedia/commons/7/73/W._Edwards_Deming.jpg\\",\\"https://upload.wikimedia.org/wikipedia/commons/b/ba/WAShewhart.jpg\\",\\"http://dit.isuct.ru/Publish_RUP/core.base_rup/guidances/supportingmaterials/resources/risk_wf.gif\\",\\"https://media.proglib.io/wp-uploads/2017/11/1-4g7Sl3v-4NtPkbduzKoRrw-300x300.png\\",\\"https://habrastorage.org/r/w1560/getpro/habr/upload_files/c59/db9/e23/c59db9e23ae81295251f732a58d8440e.png\\"],\\"dateModified\\":\\"2025-10-31T15:45:09.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://it.vshp.online/disciplines/op04/op04_15.html"}],["meta",{"property":"og:site_name","content":"Кафедра ИТ"}],["meta",{"property":"og:title","content":"ОП.04 - 15 - Итерация и итеративный процесс. Случайность в программировании. Проблемы точности вычислений"}],["meta",{"property":"og:description","content":"Примечание ЭТО АРХИВНАЯ ВЕРСИЯ КУРСА! Материалы предназначаются для пересдающих дисциплину \\"ОП.04 - Основы алгоритмизации и программирования\\" в соответствии с учебными планами С..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://upload.wikimedia.org/wikipedia/commons/3/39/Iterative_development_model.svg"}],["meta",{"property":"og:locale","content":"ru-RU"}],["meta",{"property":"og:updated_time","content":"2025-10-31T15:45:09.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-31T15:45:09.000Z"}]]},"git":{"updatedTime":1761925509000,"contributors":[{"name":"PAVEL TKACHEV","username":"","email":"phoenixweiss@ya.ru","commits":3}],"changelog":[{"hash":"799f1f79d8c5d9f1b4401f594c1135b605f001ab","time":1761925509000,"email":"phoenixweiss@ya.ru","author":"PAVEL TKACHEV","message":"Update op04_08.md, op04_09.md, op04_10.md, and 24 more files"},{"hash":"f2aeeeeab8542bec0a9ec72b857cc879e106b150","time":1761919019000,"email":"phoenixweiss@ya.ru","author":"PAVEL TKACHEV","message":"Update <a href=\\"http://index.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">index.md</a>, 2022-03-09_20-40-46.png, 2022-03-09_20-50-00.png, and 64 more files"},{"hash":"a771585bc5911f4a729d06794a6706536be6cc56","time":1761913752000,"email":"phoenixweiss@ya.ru","author":"PAVEL TKACHEV","message":"Update <a href=\\"http://index.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">index.md</a>, abacus.png, ada_lawlace.png, and 105 more files"}]},"autoDesc":true,"filePathRelative":"disciplines/op04/op04_15.md"}');export{h as comp,g as data};
