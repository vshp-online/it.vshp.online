import{_ as p,c as l,b as n,a as o,e as a,d as t,w as i,r as c,o as d}from"./app-CdTySVJ0.js";const r={},u={class:"hint-container warning"};function k(m,s){const e=c("RouteLink");return d(),l("div",null,[n("div",u,[s[5]||(s[5]=n("p",{class:"hint-container-title"},"Примечание",-1)),s[6]||(s[6]=n("p",null,[n("strong",null,"ЭТО АРХИВНАЯ ВЕРСИЯ КУРСА!")],-1)),n("p",null,[s[1]||(s[1]=a('Материалы предназначаются для пересдающих дисциплину "ОП.08 - Основы проектирования баз данных" в соответствии с учебными планами СПО годов набора ',-1)),s[2]||(s[2]=n("strong",null,"ДО 2024-го",-1)),s[3]||(s[3]=a('. Для того чтобы ознакомиться с актуальным курсом "ИТ.03 - Основы проектирования баз данных" включающим интерактивные примеры, ',-1)),t(e,{to:"/disciplines/it03/"},{default:i(()=>[...s[0]||(s[0]=[a("перейдите по ссылке",-1)])]),_:1}),s[4]||(s[4]=a(".",-1))]),s[7]||(s[7]=n("p",null,"Материалы были перенесены со старого сайта с минимальной доработкой, поэтому не все возможности курса могут работать как ожидается, где-то может слететь форматирование.",-1)),s[8]||(s[8]=n("p",null,[n("strong",null,"Домашние задания в рамках курса проверяться не будут!")],-1))]),s[9]||(s[9]=o(`<h1 id="оп-08-15-вложенные-запросы-работа-с-дублями" tabindex="-1"><a class="header-anchor" href="#оп-08-15-вложенные-запросы-работа-с-дублями"><span>ОП.08 - 15 - Вложенные запросы. Работа с дублями</span></a></h1><p>Примеры данной темы используют учебные БД:</p><details><summary><b>bookshelf.sql</b></summary><p><a href="./includes/bookshelf.sql">bookshelf.sql</a></p></details><br><details><summary><b>users_01.sql</b></summary><p><a href="./includes/users_01.sql">users_01.sql</a></p></details><h2 id="вложенные-запросы" tabindex="-1"><a class="header-anchor" href="#вложенные-запросы"><span>Вложенные запросы</span></a></h2><p>Вложенные запросы являются одним из наиболее мощных инструментов в SQL, который можно использовать в любых видах запросов. Также их часто обозначают термином «Подзапросы».</p><blockquote><p>Вложенный запрос или Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.</p></blockquote><p>Как и любой другой SQL запрос, подзапрос возвращает результирующий набор данных, который может быть одним из следующих видов:</p><ul><li>одна строка и один столбец;</li><li>нескольких строк с одним столбцом;</li><li>нескольких строк с несколькими столбцами.</li></ul><p>В зависимости от типа результирующего набора данных, определяются операторы, которые могут использоваться в основном запросе.</p><p>Например, для того чтобы получить названия книг, которые находятся на полке в кабинете, можно выполнить такой запрос:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> title <span class="token keyword">FROM</span> books</span>
<span class="line"><span class="token keyword">WHERE</span> shelves_id <span class="token operator">=</span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> shelves</span>
<span class="line">  <span class="token keyword">WHERE</span> title <span class="token operator">=</span> <span class="token string">&#39;Полка в кабинете&#39;</span></span>
<span class="line">  <span class="token keyword">LIMIT</span> <span class="token number">1</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Таким образом, сначала выполнится запрос, который вернет <code>id</code> полки с названием <code>&#39;Полка в кабинете&#39;</code>, после чего выполнится внешний запрос с переданным значением. При этом важно понимать что в зависимости от типа запроса может вернуться несколько значений, поэтому если мы хотим убедиться что останется лишь одно, лучше &quot;подстраховаться&quot; и указать <code>LIMIT 1</code>.</p><p>Однако, иногда может потребоваться чтобы в результате выполнения подзапроса вернулось несколько значений, например чтобы получить названия книг, находящихся на любой из полок в гостиной:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> title <span class="token keyword">FROM</span> books</span>
<span class="line"><span class="token keyword">WHERE</span> shelves_id <span class="token operator">IN</span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> shelves</span>
<span class="line">  <span class="token keyword">WHERE</span> title <span class="token operator">LIKE</span> <span class="token string">&#39;%в гостиной&#39;</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>здесь не только отсутствует <code>LIMIT</code>, но также изменено условие с соответствия <code>=</code> на значения в списке <code>IN</code>.</p><p>Также подзапросы могут сочетаться и с <code>JOIN</code>-ами, например если нужно найти всех авторов, книги которых стоят на полке в спальне:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> authors<span class="token punctuation">.</span>name</span>
<span class="line"><span class="token keyword">FROM</span> authors</span>
<span class="line"><span class="token keyword">JOIN</span> authors_books</span>
<span class="line"><span class="token keyword">ON</span> authors<span class="token punctuation">.</span>id <span class="token operator">=</span> authors_books<span class="token punctuation">.</span>authors_id</span>
<span class="line"><span class="token keyword">JOIN</span> books</span>
<span class="line"><span class="token keyword">ON</span> books<span class="token punctuation">.</span>id <span class="token operator">=</span> authors_books<span class="token punctuation">.</span>books_id</span>
<span class="line"><span class="token keyword">WHERE</span> books<span class="token punctuation">.</span>shelves_id <span class="token operator">=</span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> shelves</span>
<span class="line">  <span class="token keyword">WHERE</span> title <span class="token operator">=</span> <span class="token string">&#39;Полка в спальне&#39;</span></span>
<span class="line">  <span class="token keyword">LIMIT</span> <span class="token number">1</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Также в рамках запроса может быть и несколько подзапросов к разным таблицам, или даже использоваться подзапросы в подзапросах, например чтобы найти все книги, которые были написаны авторами, у которых есть книги на полке в кабинете:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> books<span class="token punctuation">.</span>title</span>
<span class="line"><span class="token keyword">FROM</span> books</span>
<span class="line"><span class="token keyword">JOIN</span> authors_books <span class="token keyword">ON</span> authors_books<span class="token punctuation">.</span>books_id <span class="token operator">=</span> books<span class="token punctuation">.</span>id</span>
<span class="line"><span class="token keyword">WHERE</span> authors_books<span class="token punctuation">.</span>authors_id <span class="token operator">IN</span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> authors_books<span class="token punctuation">.</span>authors_id</span>
<span class="line">  <span class="token keyword">FROM</span> authors_books</span>
<span class="line">  <span class="token keyword">JOIN</span> books</span>
<span class="line">  <span class="token keyword">ON</span> books<span class="token punctuation">.</span>id <span class="token operator">=</span> authors_books<span class="token punctuation">.</span>books_id</span>
<span class="line">  <span class="token keyword">WHERE</span> books<span class="token punctuation">.</span>shelves_id <span class="token operator">=</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">SELECT</span> id</span>
<span class="line">    <span class="token keyword">FROM</span> shelves</span>
<span class="line">    <span class="token keyword">WHERE</span> title <span class="token operator">=</span> <span class="token string">&#39;Полка в кабинете&#39;</span></span>
<span class="line">    <span class="token keyword">LIMIT</span> <span class="token number">1</span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>при этом сначала будет выполнен наиболее &quot;глубокий&quot; подзапрос, и так до тех пор пока не окажется достаточно данных для выполнения основного.</p><blockquote><p>[!TIP]<br> Обратите внимание что внутри скобок символ <code>;</code> не ставится. Несмотря на то что подзапросы по своей сути это отдельные запросы, но синтаксически они ограничены скобками <code>()</code>, поэтому <code>;</code> ставят только в конце основного запроса.</p></blockquote><h2 id="работа-с-дублями" tabindex="-1"><a class="header-anchor" href="#работа-с-дублями"><span>Работа с дублями</span></a></h2><p>Работа с дублирующимися записями в SQL является одной из важных задач при работе с базами данных. Дубликаты могут привести к некорректным результатам запросов и занимать место в базе данных, что может привести к снижению ее производительности.</p><p>Существует несколько способов обнаружения и удаления дубликатов в SQL. Один из самых простых способов — это использование оператора <code>DISTINCT</code> в запросах <code>SELECT</code>. Он позволяет выбрать уникальные значения из столбца или нескольких столбцов таблицы.</p><p>Например, для выборки уникальных значений из столбца &quot;name&quot; таблицы &quot;authors&quot; можно использовать следующий запрос:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> name <span class="token keyword">FROM</span> authors<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Если необходимо удалить дубликаты из таблицы, можно использовать операторы <code>GROUP BY</code> и <code>HAVING</code>. Они позволяют сгруппировать записи по определенному столбцу и выбрать только те группы, которые содержат более одной записи.</p><p>Например, для удаления дубликатов из таблицы &quot;users&quot; по столбцу &quot;email&quot; можно начать с использования следующего запроса для их нахождения:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> email</span>
<span class="line"><span class="token keyword">FROM</span> users</span>
<span class="line"><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email</span>
<span class="line"><span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>аналогичным образом можно найти дубли и по нескольким столбцам:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> guid<span class="token punctuation">,</span> email</span>
<span class="line"><span class="token keyword">FROM</span> users</span>
<span class="line"><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> guid<span class="token punctuation">,</span> email</span>
<span class="line"><span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>и в рамках владения знаниями о подзапросах, было бы логично сделать так:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> users</span>
<span class="line"><span class="token keyword">WHERE</span> email <span class="token operator">IN</span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">SELECT</span> email</span>
<span class="line">  <span class="token keyword">FROM</span> users</span>
<span class="line">  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email</span>
<span class="line">  <span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>но к сожалению именно в MySQL такой запрос не сработает из-за того же пресловутого &#39;Safe mode&#39;, и возникнет ошибка:</p><p><code>Error Code: 1093. You can&#39;t specify target table &#39;users&#39; for update in FROM clause</code></p><p>Эта ошибка возникает при использовании подзапроса в операторе <code>UPDATE</code> или <code>DELETE</code>, когда таблица, которую необходимо изменить, упоминается в подзапросе. В таком случае MySQL не позволяет изменять таблицу, которая используется в подзапросе, чтобы избежать конфликтов с блокировками и транзакциями.</p><p>Для решения этой проблемы можно использовать временную таблицу или присвоить алиас таблице в подзапросе. Например, для удаления дубликатов из таблицы &quot;users&quot; по столбцу &quot;email&quot; можно использовать следующий запрос:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> users</span>
<span class="line"><span class="token keyword">WHERE</span> email <span class="token operator">IN</span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">SELECT</span> email</span>
<span class="line">  <span class="token keyword">FROM</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> email <span class="token keyword">FROM</span> users <span class="token punctuation">)</span> <span class="token keyword">AS</span> users_tmp</span>
<span class="line">  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email</span>
<span class="line">  <span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token operator">AND</span> id <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>[!WARNING]<br> Важно понимать что такой метод прямого удаления фактически удалит все записи которые имеют дублирующиеся значения <code>email</code>!</p></blockquote><p>В этом запросе мы создаем временную таблицу с помощью подзапроса <code>SELECT email FROM users</code> и присваиваем ей алиас &quot;users_tmp&quot;. Затем мы группируем записи по столбцу &quot;email&quot; и выбираем только те группы, которые содержат более одной записи. Наконец, мы удаляем все записи из таблицы &quot;users&quot;, у которых значение столбца &quot;email&quot; содержится в выбранных группах. Кроме того, не забываем об еще одном ограничении &#39;Safe mode&#39; — необходимости указать явно первичный ключ, которое мы также учли через <code>id &gt; 0</code>.</p><hr><p>И тем не менее, намного более грамотный вариант решения подобной задачи — это удаление всех дублирующихся записей кроме первой найденной:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> email <span class="token operator">IN</span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">SELECT</span> email <span class="token keyword">FROM</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token keyword">SELECT</span> email<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token keyword">AS</span> min_id <span class="token keyword">FROM</span> users</span>
<span class="line">    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> email</span>
<span class="line">  <span class="token punctuation">)</span> <span class="token keyword">AS</span> tmp <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> min_id</span>
<span class="line"><span class="token punctuation">)</span> <span class="token operator">AND</span> id <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Этот запрос удаляет дубликаты из таблицы <code>users</code>, оставляя только записи с наименьшим значением <code>id</code> для каждого уникального значения <code>email</code>. Таким образом, он решает проблему без необходимости отключения &#39;Safe mode&#39;. Однако, такой запрос может быть более сложным для понимания и использования, особенно для новичков в SQL.</p><blockquote><p>[!TIP]<br> В общем виде, нахождение и удаление дубликатов записей в автоматическом режиме — это довольно опасная задача, поэтому перед выполнением данной операции, как правило, правильнее для начала снять дамп с БД или с отдельной таблицы в которой планируется искать дубли. Как правило, решение дубль это или нет лучше принимать осознанно, держа в уме что чем больше массив данных тем больше вероятность встретить повторяющиеся значения, не являющиеся аномалиями БД, например — полных однофамильцев рожденных в один день, что на практике совершенно не такая фантастическая ситуация даже для небольших БД.</p></blockquote><p>Отдельно стоит сказать что существуют и специальные инструменты для обнаружения и удаления дубликатов в SQL, например различные утилиты, которые позволяют быстро и эффективно найти и удалить дубликаты в больших таблицах, однако это уже выходит за рамки нашего курса.</p>`,48))])}const b=p(r,[["render",k]]),y=JSON.parse('{"path":"/disciplines/op08/op08_15.html","title":"ОП.08 - 15 - Вложенные запросы. Работа с дублями","lang":"ru-RU","frontmatter":{"description":"Примечание ЭТО АРХИВНАЯ ВЕРСИЯ КУРСА! Материалы предназначаются для пересдающих дисциплину \\"ОП.08 - Основы проектирования баз данных\\" в соответствии с учебными планами СПО годов...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ОП.08 - 15 - Вложенные запросы. Работа с дублями\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-31T15:45:09.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://it.vshp.online/disciplines/op08/op08_15.html"}],["meta",{"property":"og:site_name","content":"Кафедра ИТ"}],["meta",{"property":"og:title","content":"ОП.08 - 15 - Вложенные запросы. Работа с дублями"}],["meta",{"property":"og:description","content":"Примечание ЭТО АРХИВНАЯ ВЕРСИЯ КУРСА! Материалы предназначаются для пересдающих дисциплину \\"ОП.08 - Основы проектирования баз данных\\" в соответствии с учебными планами СПО годов..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ru-RU"}],["meta",{"property":"og:updated_time","content":"2025-10-31T15:45:09.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-31T15:45:09.000Z"}]]},"git":{"updatedTime":1761925509000,"contributors":[{"name":"PAVEL TKACHEV","username":"","email":"phoenixweiss@ya.ru","commits":2}],"changelog":[{"hash":"799f1f79d8c5d9f1b4401f594c1135b605f001ab","time":1761925509000,"email":"phoenixweiss@ya.ru","author":"PAVEL TKACHEV","message":"Update op04_08.md, op04_09.md, op04_10.md, and 24 more files"},{"hash":"a771585bc5911f4a729d06794a6706536be6cc56","time":1761913752000,"email":"phoenixweiss@ya.ru","author":"PAVEL TKACHEV","message":"Update <a href=\\"http://index.md\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">index.md</a>, abacus.png, ada_lawlace.png, and 105 more files"}]},"autoDesc":true,"filePathRelative":"disciplines/op08/op08_15.md"}');export{b as comp,y as data};
