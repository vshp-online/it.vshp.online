# МДК.11.01 - 15 - Расширенные транзакции

Примеры данной темы используют учебную БД:

::: tabs

@tab Структура БД

@[code mermaid](./includes/transactions_example.mermaid)

@tab Дамп

@[code sql:collapsed-lines=10](./includes/transactions_example.sql)

@tab Таблицы

  ::: tabs

  @tab **users**
  <!-- @include: ./includes/transactions_example_table_users.md -->

  @tab **accounts**
  <!-- @include: ./includes/transactions_example_table_accounts.md -->

  :::

:::

## Уровни изоляции транзакций

В MySQL 8 существует четыре уровня изоляции транзакций: `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ` и `SERIALIZABLE`.

Все примеры ниже будут использовать код двух транзакций:

Транзакция 1:

```sql
START TRANSACTION;
UPDATE accounts SET balance = balance + 1000 WHERE id = 1;
```

Транзакция 2:

```sql
START TRANSACTION;
UPDATE accounts SET balance = balance + 250 WHERE id = 1;
COMMIT;
```

Уровни изоляции позволяют настроить баланс между производительностью и надежностью транзакций в зависимости от требований приложения.

1. `READ UNCOMMITTED` (неподтвержденное чтение): Этот уровень позволяет одной транзакции читать неподтвержденные изменения, внесенные другой транзакцией.

  Чтобы задать соответствующий уровень, после начала транзакции, необходимо его установить командой:

  ```sql
  SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
  ```

  Если транзакция 1 выполняется в режиме `READ UNCOMMITTED`, она сможет прочитать изменения, внесенные транзакцией 2, даже до ее подтверждения.

2. `READ COMMITTED` (подтвержденное чтение): Этот уровень позволяет транзакции читать только подтвержденные изменения других транзакций.

  Чтобы задать соответствующий уровень, после начала транзакции, необходимо его установить командой:

  ```sql
  SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
  ```

  Если транзакция 1 выполняется в режиме `READ COMMITTED`, она не сможет прочитать изменения, внесенные транзакцией 2, до ее подтверждения.

3. `REPEATABLE READ` (повторяемое чтение): Этот уровень гарантирует, что транзакция будет видеть одни и те же данные при повторном чтении в рамках одной транзакции.

  Чтобы задать соответствующий уровень, после начала транзакции, необходимо его установить командой:

  ```sql
  SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
  ```

  Если транзакция 1 выполняется в режиме `REPEATABLE READ`, она будет видеть исходные данные при повторном чтении, даже после подтверждения изменений транзакцией 2.

4. `SERIALIZABLE` (сериализуемое чтение): Этот уровень гарантирует полную изоляцию транзакций, предотвращая конфликты и аномалии.

  Чтобы задать соответствующий уровень, после начала транзакции, необходимо его установить командой:

  ```sql
  SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  ```

  Если транзакция 1 выполняется в режиме `SERIALIZABLE`, она будет заблокирована до подтверждения изменений транзакцией 2, чтобы избежать возможных конфликтов.

---

### Возможные аномалии по уровням

| Уровень изоляции | Потерянное обновление | «Грязное» чтение | Неповторяющееся чтение | Чтение «фантомов» |
| :-----: | :-: | :-: | :-: | :-: |
| `NONE` | ДА | ДА | ДА | ДА |
| `READ UNCOMMITTED` | НЕТ | ДА | ДА | ДА |
| `READ COMMITTED` | НЕТ | НЕТ | ДА | ДА |
| `REPEATABLE READ` | НЕТ | НЕТ | НЕТ | ДА |
| `SERIALIZABLE` | НЕТ | НЕТ | НЕТ | НЕТ |

- **Потерянное обновление** — Ситуация, когда при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется.

- **«Грязное» чтение** — Чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится).

- **Неповторяющееся чтение** — Ситуация, когда при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.

- **Чтение «фантомов»** — Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

### Уровень изоляции по-умолчанию

Чтобы узнать уровень изоляции транзакций, используемый по умолчанию в MySQL 8, можно выполнить следующий запрос:

```sql
SELECT @@global.transaction_isolation;
```

Этот запрос вернет текущее значение переменной `transaction_isolation`, которая указывает на уровень изоляции транзакций, используемый по умолчанию. Возможные значения переменной `transaction_isolation` включают `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` и `NONE`.

::: warning

Обратите внимание, что доступ к этой информации может потребовать привилегий администратора базы данных.

:::

## Работа с точками восстановления

Точка восстановления, или `SAVEPOINT` — это зафиксированное состояние БД к которому можно откатиться в рамках команды `ROLLBACK`.

Допустим, пользователь `Иванов Иван Иванович` переводит деньги сразу нескольким пользователям в рамках одной "сделки". Логично оформить набор запросов в виде единой транзакции, но при этом зафиксировать состояния внутри неё, чтобы иметь возможность откатиться на любой шаг.

1. Начинаем транзакцию:

```sql
START TRANSACTION;
```

2. Получаем текущий баланс Иванова и номер его основного счета:

```sql
SELECT id, balance FROM accounts WHERE user_id = 1 AND title = 'Основной';
```

3. Фиксируем состояния до того как начали перевод средств:

```sql
SAVEPOINT SavePoint1;
```

4. Переводим `5000` рублей с основного счёта Иванова на основной счёт Петрова:

```sql
UPDATE accounts SET balance = balance - 5000 WHERE id = 1;
UPDATE accounts SET balance = balance + 5000 WHERE id = 3;
```

5. Фиксируем состояние в этой точке:

```sql
SAVEPOINT SavePoint2;
```

6. Переводим `1500` рублей с основного счёта Иванова на основной счёт Сидорова:

```sql
UPDATE accounts SET balance = balance - 1500 WHERE id = 1;
UPDATE accounts SET balance = balance + 1500 WHERE id = 4;
```

7. Фиксируем состояние в этой точке:

```sql
SAVEPOINT SavePoint3;
```

8. Посмотрим сколько денег осталось на основном счёте Иванова:

```sql
SELECT id, balance FROM accounts WHERE user_id = 1 AND title = 'Основной';
```

На данный момент у нас есть возможность произвести следующие действия:

- Если всё прошло хорошо, и результаты всех действий нас устроили, можем зафиксировать результаты при помощи `COMMIT;`.
- Если нам нужно откатиться на состояние после того как мы перевели деньги Сидорову, можем выполнить `ROLLBACK TO SavePoint3;`.
- Если нам нужно откатиться на состояние после того как мы перевели деньги Петрову, но до того как мы начали переводить деньги Сидорову, можем выполнить `ROLLBACK TO SavePoint2;`.
- Если нам нужно откатиться на состояние до того как мы начали переводить деньги, можем выполнить `ROLLBACK TO SavePoint1;`.
- Если нужно вернуть БД в состояние как будто целой транзакции не было, используем просто `ROLLBACK;`, при этом промежуточные состояния точек восстановления учтены не будут.
- Если какая-либо из точек восстановления уже не нужна, очистить её из памяти можно при помощи команды `RELEASE SAVEPOINT SavePoint1;`.

::: warning

Важно, что откатывая состояние на более раннюю точку восстановления, мы также лишаем себя возможности восстановиться на более поздней. То есть, возвращаясь в более раннюю точку мы фактически возвращаемся в состояние в котором более поздних просто не существовало!

:::

::: info

Стоит учесть что в большинстве СУБД после закрытия транзакции, откатиться на точку восстановления уже не выйдет, поэтому для сохранения состояния БД между транзакциями используются уже другие механизмы.

:::
