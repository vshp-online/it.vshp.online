# ИТ.03 - 09 - Основные типы данных SQLite. Работа с датой и временем. Создание и удаление таблиц

## Введение

В предыдущих темах мы научились извлекать, фильтровать и модифицировать данные в уже существующих таблицах. Но прежде чем работать с данными, необходимо создать структуру для их хранения — таблицы.

В этой теме мы рассмотрим:

- Основные типы данных в SQLite и их сравнение с MySQL
- Работу с датой и временем в SQLite
- Как создавать таблицы с помощью оператора `CREATE TABLE`
- Как удалять таблицы с помощью оператора `DROP TABLE`

Эти операции относятся к DDL (Data Definition Language) — языку определения данных, который позволяет создавать и изменять структуру базы данных.

При создании таблиц мы будем использовать типы данных, которые совместимы как с SQLite, так и с MySQL, чтобы облегчить переход к изучению MySQL в дальнейшем.

## Типы данных в SQLite

В отличие от большинства других СУБД, SQLite использует динамическую типизацию. Это означает, что тип значения определяется не по типу столбца таблицы, а по значению самого значения.

Тем не менее, при определении структуры таблицы мы можем указывать типы данных для столбцов, что помогает лучше понимать структуру данных и улучшает читаемость кода. При этом мы будем использовать типы, которые совместимы с MySQL, чтобы облегчить дальнейшее изучение.

### Основные типы данных SQLite

SQLite поддерживает следующие категории типов данных:

#### 1. **NULL**

Значение NULL представляет собой "пустое" значение, отсутствие данных.

#### 2. **INTEGER**

Целочисленные значения. В зависимости от величины числа SQLite использует разное количество байт для хранения:

- 1, 2, 3, 4, 6 или 8 байт

В MySQL аналогичными типами являются `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`. В SQLite мы используем просто `INTEGER` для всех целочисленных значений.

#### 3. **REAL**

Числа с плавающей точкой (вещественные числа), хранятся в 8-байтовом формате IEEE.

В MySQL это соответствует типу `DOUBLE`. Для меньшей точности можно использовать `FLOAT`, но в SQLite это будет также храниться как `REAL`.

#### 4. **TEXT**

Текстовые строки, хранятся в кодировке UTF-8, UTF-16BE или UTF-16LE.

В MySQL это соответствует типам `CHAR`, `VARCHAR`, `TEXT` и их вариантам. В SQLite мы используем просто `TEXT` для всех текстовых данных.

#### 5. **BLOB**

Двоичные данные (Binary Large Object), хранятся "как есть", без преобразований.

В MySQL это соответствует типам `BLOB`, `TINYBLOB`, `MEDIUMBLOB`, `LONGBLOB`.

::: info Зачем нужны типы данных?

Правильный выбор типов данных влияет на:

- **Размер базы данных** — числа занимают меньше места, чем их текстовое представление
- **Скорость поиска и фильтрации** — поиск по числовым полям быстрее, чем по текстовым
- **Доступные функции** — для чисел доступны математические операции, для дат — функции работы с календарем
- **Целостность данных** — типы данных помогают предотвратить ошибки ввода

:::

### Как SQLite определяет типы данных (Type Affinity)

При создании таблиц в SQLite вы можете указывать различные типы данных для столбцов, но SQLite интерпретирует их по-своему. Эта особенность называется "типизирующее сходство" или "type affinity".

Когда вы указываете тип данных для столбца, SQLite пытается определить, к какой из пяти основных категорий он относится:

1. **Числовой тип (INTEGER)** — для целых чисел
2. **Вещественный тип (REAL)** — для чисел с плавающей точкой
3. **Текстовый тип (TEXT)** — для строк
4. **Двоичный тип (BLOB)** — для бинарных данных
5. **Числовой тип (NUMERIC)** — для остальных случаев

Это означает, что даже если вы укажете тип `VARCHAR(255)` или `DATETIME`, SQLite преобразует его в одну из этих пяти категорий.

Например:

- Если вы укажете тип `INT`, `INTEGER`, `TINYINT`, `BIGINT` и т.д., SQLite будет считать это числовым типом INTEGER
- Если вы укажете тип `CHAR`, `VARCHAR`, `TEXT` и т.д., SQLite будет считать это текстовым типом TEXT
- Если вы укажете тип `FLOAT`, `DOUBLE`, SQLite будет считать его вещественным типом REAL
- Если вы укажете тип `BLOB`, SQLite будет считать его двоичным типом BLOB
- Если вы укажете тип `DATE`, `DATETIME`, SQLite будет считать это числовым типом NUMERIC

::: warning Что произойдет, если положить текст в числовое поле?

SQLite позволяет хранить значения любого типа в любом столбце, независимо от объявленного типа. Это означает, что вы можете положить текст "привет" в числовое поле INTEGER.

Однако это может привести к неожиданным результатам:

- При математических операциях текст будет преобразован в 0
- При сортировке текстовые значения будут упорядочены по-другому, чем числа
- Это может затруднить поиск и фильтрацию данных

Поэтому важно придерживаться объявленных типов данных для обеспечения целостности и предсказуемости работы с базой данных.

:::

### Сравнение типов данных SQLite и MySQL

Для облегчения перехода к изучению MySQL важно понимать, как типы данных SQLite соотносятся с типами MySQL:

| SQLite | MySQL | Назначение |
|--------|-------|------------|
| INTEGER | INT, BIGINT | Целые числа |
| REAL | DOUBLE, FLOAT | Вещественные числа |
| TEXT | CHAR, VARCHAR, TEXT | Текстовые данные |
| BLOB | BLOB | Двоичные данные |
| - | DATE, TIME, DATETIME | Календарные данные (в SQLite хранятся как TEXT) |

При создании таблиц в SQLite мы будем использовать типы, которые имеют прямые аналоги в MySQL, чтобы облегчить дальнейшее изучение.

## Работа с датой и временем в SQLite

Важно понимать, что SQLite не имеет отдельных типов данных для хранения даты и времени. Это не значит, что вы не можете хранить даты в SQLite — просто они будут храниться как текст или числа, но с определенными правилами обработки.

В SQLite дата и время хранятся в виде:

- TEXT (в формате ISO8601: "YYYY-MM-DD HH:MM:SS.SSS")
- REAL (в виде количества дней с момента дня в юлианском календаре)
- INTEGER (в виде количества секунд с 1970-01-01 00:00:00 UTC)

Несмотря на это, SQLite предоставляет богатый набор функций для работы с датами и временем.

::: info Зачем используется юлианский день?

Функция `julianday()` возвращает количество дней с юлианской эпохи (полдень 1 января 4713 г. до н.э. по юлианскому календарю). Это может показаться странным, но на самом деле это очень удобно для вычислений:

- Это позволяет представлять любую дату в истории в виде одного числа
- Для вычисления разницы между датами достаточно просто вычесть одно число из другого
- Например, `julianday('2025-12-31') - julianday('2025-01-01')` сразу даст вам количество дней между этими датами

Юлианский календарь, введенный Юлием Цезарем в 46 году до н.э., имеет год продолжительностью ровно 365.25 дней (365 дней и один дополнительный день каждые 4 года). Именно из-за этого усредненного значения юлианский календарь постепенно отстает от реального солнечного года, который составляет примерно 365.2422 дней.

В результате к настоящему времени юлианский календарь отстает от принятого сегодня григорианского календаря примерно на 13 дней. Несмотря на это, юлианская система счисления дней продолжает использоваться в астрономии и в системах баз данных, таких как SQLite, благодаря своей простоте и удобству для вычислений.

:::

### Форматы хранения даты и времени

#### формат `TEXT`

Строка в формате "YYYY-MM-DD HH:MM:SS.SSS". Это наиболее распространенный формат.

Пример: "2025-11-05 15:30:00.000"

#### формат `REAL`

Число дней с полудня 24 ноября 4714 г. до н.э. по юлианскому календарю.

#### формат `INTEGER` (Unix time)

Число секунд с 1970-01-01 00:00:00 UTC (Unix время).

::: info Unix time

Unix time (время Unix) — это количество секунд, прошедших с 1 января 1970 года 00:00:00 UTC. Это стандартный способ представления времени в компьютерных системах.

Преимущества Unix time:

- Простота хранения — одно целое число
- Удобство для вычислений — разница во времени равна разнице чисел
- Универсальность — используется во многих системах и языках программирования

:::

::: warning Временные зоны и время сервера

При использовании функций времени в SQLite, таких как `time('now')`, важно понимать, что они возвращают время в формате UTC (GMT 0), без учета временной зоны сервера.

Например, если у вас в Москве (GMT +3), текущее время 15:00, то `SELECT time('now');` может вернуть 12:00 — это время по Гринвичу, а не по вашему местному времени.

Для получения времени с учетом временной зоны используйте модификатор `localtime`. Пример: `SELECT time('now', 'localtime');`

:::

### Функции работы с датой и временем

SQLite предоставляет следующие функции для работы с датами и временем:

#### date()

`date(timestring, modifier, modifier, ...)`

Возвращает дату в формате "YYYY-MM-DD".

Примеры:

::: play sandbox=sqlite editor=basic

```sql
-- Текущая дата
SELECT date('now');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Дата через 3 дня
SELECT date('now', '+3 days');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Дата начала текущего месяца
SELECT date('now', 'start of month');
```

:::

#### time()

`time(timestring, modifier, modifier, ...)`

Возвращает время в формате "HH:MM:SS".

Примеры:

::: play sandbox=sqlite editor=basic

```sql
-- Текущее время (UTC)
SELECT time('now');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Текущее время (локальное)
SELECT time('now', 'localtime');
```

:::

::: warning

В данном случае время может вернуться то же самое, т.к. на сервере у нас не настроена временная зона.

:::

::: play sandbox=sqlite editor=basic

```sql
-- Время через 3 часа
SELECT time('now', '+3 hours');
```

:::

#### datetime()

`datetime(timestring, modifier, modifier, ...)`

Возвращает дату и время в формате "YYYY-MM-DD HH:MM:SS".

Примеры:

::: play sandbox=sqlite editor=basic

```sql
-- Текущая дата и время (UTC)
SELECT datetime('now');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Текущая дата и время (локальное)
SELECT datetime('now', 'localtime');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Дата и время через 1 час
SELECT datetime('now', '+1 hour');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Дата и время через 1 неделю
SELECT datetime('now', '+7 days');
```

:::

#### strftime()

`strftime(format, timestring, modifier, modifier, ...)`

Возвращает дату/время в заданном формате.

Основные переменные формата:

| Переменная | Описание | Пример |
|----------|----------|--------|
| %Y | Год (4 цифры) | 2025 |
| %m | Месяц (01-12) | 03 |
| %d | День месяца (01-31) | 15 |
| %H | Час (00-23) | 14 |
| %M | Минуты (00-59) | 30 |
| %S | Секунды (00-59) | 45 |
| %w | День недели (0-6, где 0=воскресенье) | 3 |

Примеры:

::: play sandbox=sqlite editor=basic

```sql
-- Год
SELECT strftime('%Y', 'now');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Месяц и год
SELECT strftime('%m-%Y', 'now');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- День месяца
SELECT strftime('%d', 'now');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- День недели (1-7, где 1=понедельник)
SELECT strftime('%w', 'now');
```

:::

#### julianday()

`julianday(timestring, modifier, modifier, ...)`

Возвращает количество дней с юлианской эпохи.

Примеры:

::: play sandbox=sqlite editor=basic

```sql
-- Юлианский день для текущей даты
SELECT julianday('now');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Разница в днях между двумя датами
SELECT julianday('2025-12-31') - julianday('2025-01-01');
```

:::

### Модификаторы даты и времени

Модификаторы позволяют изменять дату и время:

- `NNN days`, `NNN hours`, `NNN minutes`, `NNN seconds`
- `NNN months`, `NNN years`
- `start of month`, `start of year`, `start of day`
- `weekday N` (переход к дню недели)
- `unixepoch` (для работы с Unix временем)
- `utc`, `localtime` (преобразование часовых поясов)

Примеры:

::: play sandbox=sqlite editor=basic

```sql
-- Первый день следующего месяца
SELECT date('now', '+1 month', 'start of month');
```

:::

::: play sandbox=sqlite editor=basic

```sql
-- Последний день текущего месяца
SELECT date('now', 'start of month', '+1 month', '-1 day');
```

:::

## Создание таблиц (CREATE TABLE)

Для создания новой таблицы в базе данных используется оператор `CREATE TABLE`.

### Базовый синтаксис

```sql
CREATE TABLE [IF NOT EXISTS] имя_таблицы (
  имя_столбца1 тип_данных [ограничения],
  имя_столбца2 тип_данных [ограничения],
  ...
  [ограничения_таблицы]
);
```

::: warning

Операторы создания таблиц **не выводят изменения на экран**. Чтобы убедиться что таблица была успешно создана с заданными параметрами, в SQLite можно использовать конструкцию `PRAGMA table_info('имя_таблицы');` **после** создания таблицы.

```sql {#auto_pragma_after}
-- здесь может идти код создания таблицы:
##CODE##

-- запрашиваем структуру таблицы:
PRAGMA table_info('employees');
```

В отличие от прошлых лекций, мы не будем использовать автоматически конструкцию `PRAGMA table_info('имя_таблицы');` для всех блоков кода, оставим только там где нужно.

:::

### Пример простой таблицы

Рассмотрим создание таблицы для хранения информации о сотрудниках:

::: play sandbox=sqlite editor=basic template="#auto_pragma_after" id=employees_create.sql

```sql
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  salary INTEGER NOT NULL,
  department TEXT,
  hire_date TEXT DEFAULT (date('now'))
);
```

:::

В этом примере:

- `id` — целочисленный столбец, являющийся первичным ключом
- `first_name` и `last_name` — текстовые столбцы, обязательные для заполнения
- `salary` — целочисленный столбец, обязательный для заполнения
- `department` — текстовый столбец, необязательный (может содержать NULL)
- `hire_date` — текстовый столбец с датой найма по умолчанию

::: tip

Для того чтобы посмотреть исходны код при помощи которого была создана таблица, в SQLite можно воспользоваться командой `.schema`, например:

  ::: play sandbox=sqlite editor=basic depends-on=employees_create.sql

  ```sql
  .schema employees
  ```

  :::

Таким образом можно получить код создания любой таблицы в базе данных.

:::

### Ограничения (Constraints)

При создании таблиц можно задавать различные ограничения, которые обеспечивают целостность данных:

#### PRIMARY KEY

Уникальный идентификатор записи в таблице. Может быть только один первичный ключ в таблице.

```sql
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);
```

#### NOT NULL

Запрещает хранить в столбце значение NULL.

```sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  username TEXT NOT NULL,
  email TEXT
);
```

#### UNIQUE

Гарантирует уникальность значений в столбце.

```sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  username TEXT UNIQUE,
  email TEXT UNIQUE
);
```

#### CHECK

Позволяет задать условие, которому должны соответствовать значения в столбце.

```sql
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  age INTEGER CHECK (age >= 0 AND age < 150),
  salary INTEGER CHECK (salary > 0)
);
```

#### DEFAULT

Задает значение по умолчанию для столбца.

```sql
CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  product_name TEXT NOT NULL,
  quantity INTEGER DEFAULT 1,
  status TEXT DEFAULT 'pending',
  created_at TEXT DEFAULT (datetime('now'))
);
```

#### FOREIGN KEY

Создает связь между таблицами (внешний ключ).

```sql
CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer_id INTEGER,
  product_id INTEGER,
  quantity INTEGER,
  FOREIGN KEY (customer_id) REFERENCES customers (id),
  FOREIGN KEY (product_id) REFERENCES products (id)
);
```

::: info

Более подробно про связи таблиц через внешние ключи мы рассмотрим дальше в рамках данного курса.

:::

### Пример сложной таблицы с ограничениями

::: play sandbox=sqlite editor=basic id=complex_table.sql

```sql
CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer_name TEXT NOT NULL,
  product_name TEXT NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
  price REAL NOT NULL CHECK (price >= 0),
  order_date TEXT DEFAULT (date('now')),
  delivery_date TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'shipped', 'delivered', 'cancelled')),
  CHECK (delivery_date >= order_date OR delivery_date IS NULL)
);
```

:::

В этом примере:

- `id` — первичный ключ
- `customer_name` и `product_name` — обязательные текстовые поля
- `quantity` — целое число по умолчанию 1, с проверкой на положительность
- `price` — вещественное число с проверкой на неотрицательность
- `order_date` — дата заказа по умолчанию (текущая дата)
- `delivery_date` — дата доставки (может быть NULL)
- `status` — текстовое поле с ограниченным набором значений
- Проверка, что дата доставки не меньше даты заказа

## Удаление таблиц (DROP TABLE)

Для удаления таблицы используется оператор `DROP TABLE`.

### Базовый синтаксис

```sql
DROP TABLE [IF EXISTS] имя_таблицы;
```

### Примеры

Удаление существующей таблицы:

::: play sandbox=sqlite editor=basic depends-on=employees_create.sql

```sql
DROP TABLE employees;
```

:::

Безопасное удаление таблицы (не вызывает ошибку, если таблицы не существует):

::: play sandbox=sqlite editor=basic

```sql
DROP TABLE IF EXISTS non_existent_table;
```

:::

## Практические задания

### Задание 1

::: tabs

@tab Условие

Создайте таблицу `students` со следующими полями:

- `id` — целое число, первичный ключ
- `name` — текст, обязательное поле
- `age` — целое число, обязательное поле
- `group_name` — текст, необязательное поле
- `gpa` — вещественное число, значение по умолчанию 0.0
- `enrollment_date` — текст, дата зачисления, по умолчанию текущая дата

После создания таблицы выведите информацию о ее структуре.

  ::: play sandbox=sqlite editor=basic

  ```sql
  -- Ваш код можете писать тут


  ```

  :::

@tab Решение

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  age INTEGER NOT NULL,
  group_name TEXT,
  gpa REAL DEFAULT 0.0,
  enrollment_date TEXT DEFAULT (date('now'))
);

PRAGMA table_info('students');
```

:::

### Задание 2

::: tabs

@tab Условие

Создайте таблицу `products` со следующими полями:

- `id` — целое число, первичный ключ
- `name` — текст, обязательное поле, уникальное
- `category` — текст, обязательное поле
- `price` — вещественное число, обязательное поле, должно быть больше 0
- `in_stock` — целое число, значение по умолчанию 0, должно быть не меньше 0
- `created_at` — текст, дата создания, по умолчанию текущая дата и время

После создания таблицы выведите информацию о ее структуре.

  ::: play sandbox=sqlite editor=basic

  ```sql
  -- Ваш код можете писать тут


  ```

  :::

@tab Решение

```sql
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  category TEXT NOT NULL,
  price REAL NOT NULL CHECK (price > 0),
  in_stock INTEGER DEFAULT 0 CHECK (in_stock >= 0),
  created_at TEXT DEFAULT (datetime('now'))
);

PRAGMA table_info('products');
```

:::

### Задание 3

::: tabs

@tab Условие

Удалите таблицу `non_existent_table`, если она существует. Если таблицы нет, ошибок не должно быть.

  ::: play sandbox=sqlite editor=basic

  ```sql
  -- Ваш код можете писать тут


  ```

  :::

@tab Решение

```sql
DROP TABLE IF EXISTS non_existent_table;
```

:::

### Задание 4

::: tabs

@tab Условие

Используя функции работы с датами и временем SQLite, выполните следующие запросы:

1. Выведите текущую дату
2. Выведите текущее время
3. Выведите текущую дату и время

  ::: play sandbox=sqlite editor=basic

  ```sql
  -- Ваш код можете писать тут


  ```

  :::

@tab Решение

```sql
-- 1. Текущая дата
SELECT date('now');

-- 2. Текущее время
SELECT time('now');

-- 3. Текущая дата и время
SELECT datetime('now');
```

:::

### Задание 5

::: tabs

@tab Условие

Используя модификаторы даты и времени SQLite, выполните следующие запросы:

1. Выведите дату, которая будет через 5 дней от текущей даты
2. Выведите дату начала текущего месяца
3. Выведите дату и время через 2 часа от текущего момента

  ::: play sandbox=sqlite editor=basic

  ```sql
  -- Ваш код можете писать тут


  ```

  :::

@tab Решение

```sql
-- 1. Дата через 5 дней
SELECT date('now', '+5 days');

-- 2. Дата начала текущего месяца
SELECT date('now', 'start of month');

-- 3. Дата и время через 2 часа
SELECT datetime('now', '+2 hours');
```

:::

### Задание 6

::: tabs

@tab Условие

Создайте таблицу `events` для хранения информации о событиях со следующими полями:

- `id` — целое число, первичный ключ
- `title` — текст, обязательное поле
- `start_date` — текст, дата начала события, обязательное поле
- `end_date` — текст, дата окончания события, необязательное поле
- `created_at` — текст, дата создания записи, по умолчанию текущая дата и время

После создания таблицы:

1. Вставьте в таблицу несколько записей с различными датами
2. Выведите все события, отсортировав их по дате начала

  ::: play sandbox=sqlite editor=basic

  ```sql
  -- Ваш код можете писать тут


  ```

  :::

@tab Решение

```sql
-- Создание таблицы
CREATE TABLE events (
  id INTEGER PRIMARY KEY,
  title TEXT NOT NULL,
  start_date TEXT NOT NULL,
  end_date TEXT,
  created_at TEXT DEFAULT (datetime('now'))
);

-- Вставка записей
INSERT INTO events (title, start_date, end_date) VALUES
  ('Проектное собрание', '2025-11-10', '2025-11-10'),
  ('Конференция', '2025-12-01', '2025-12-03'),
  ('Дедлайн отчета', '2025-11-15', NULL);

-- Все события, отсортированные по дате начала
SELECT * FROM events ORDER BY start_date;
```

:::
