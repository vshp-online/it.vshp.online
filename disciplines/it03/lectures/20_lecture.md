# ИТ.03 - 20 - Индексы и производительность в MySQL

::: warning
Лекция находится в промежуточном состоянии и будет дорабатываться.
:::

## Введение

На прошлом занятии мы разобрали ограничения и целостность данных. Следующий шаг - понять, как сохранять приемлемую скорость запросов при росте объема таблиц.

Главный инструмент на старте этой темы - индексы.

Индекс не меняет сами данные, но меняет способ доступа к ним: MySQL может читать значительно меньше строк, если нужный столбец проиндексирован.

В этой лекции разберем базовую практику:

- что такое индекс и зачем он нужен;
- как устроен поиск с индексом и без него;
- чем отличается уникальный и неуникальный индекс;
- как в MySQL добавить, посмотреть и удалить индекс;
- как базово проверить использование индекса через `EXPLAIN`.

---

## Что такое индекс

Индекс в БД - это специальная структура данных, которая помогает быстрее находить строки по значениям столбцов.

Если очень упрощенно:

- без индекса MySQL чаще читает таблицу почти целиком;
- с индексом MySQL может перейти сразу к нужному диапазону строк.

Обычно индексы делают для полей, которые часто участвуют в:

- `WHERE`
- `JOIN`
- `ORDER BY`

---

## Как работает поиск без индекса и с индексом

### Без индекса

Сервер перебирает строки одну за другой. Чем больше таблица, тем дольше поиск.

### С индексом

Сервер использует индекс и сразу идет в нужную часть данных, поэтому читает меньше строк.

```mermaid
flowchart LR
  A["Запрос по полю email"] --> B{"Есть индекс по email?"}
  B -->|"Нет"| C["Чтение почти всей таблицы"]
  B -->|"Да"| D["Переход по индексу к нужным строкам"]
  D --> E["Более быстрый результат"]
```

---

## Почему индекс работает быстро

В MySQL обычные индексы устроены как B-Tree (древовидная структура из узлов и уровней).

Простая аналогия: это как оглавление в большой книге.

- без оглавления пришлось бы листать страницы подряд;
- с оглавлением мы сначала находим раздел, потом подраздел, и только затем нужную страницу.

С индексом в БД происходит то же самое: MySQL идет по диапазонам ключей сверху вниз и быстро отбрасывает лишние данные.

Структура B-Tree в упрощенном виде:

<!-- @include: ./includes/index_btree_structure.plantuml -->

Как индекс обычно строится:

<!-- @include: ./includes/index_build_steps.plantuml -->

То есть индекс - это не «магия», а отдельная упорядоченная структура, где хранятся ключи и ссылки на строки.

Наглядно (оценка порядка роста числа сравнений):

| Количество строк | Примерное число сравнений |
| --- | --- |
| 10 | ~3 |
| 100 | ~7 |
| 1 000 | ~10 |
| 10 000 | ~13 |
| 100 000 | ~17 |
| 1 000 000 | ~20 |

::: note
Эффект максимальный, когда значения в индексируемом поле достаточно разнообразные. Если в поле почти везде одно и то же значение, польза ниже.
:::

---

## Уникальный и неуникальный индекс

### Неуникальный индекс

Нужен, чтобы ускорить поиск. Повторяющиеся значения допускаются.

Пример: индекс по `city_id`.

### Уникальный индекс

Нужен и для скорости, и для контроля уникальности. Дубли запрещены.

Пример: индекс по `email`.

---

## Наглядные иллюстрации индексов

Сравнение пути выполнения запроса:

<!-- @include: ./includes/index_lookup_compare.plantuml -->

Мини-пример на словах:

- ищем пользователя с `email = 'anna@example.com'`;
- без индекса сервер проверяет много строк подряд;
- с индексом сервер идет по дереву ключей и быстро попадает в нужный лист;
- затем читает только нужную строку.

---

## Учебная база для примеров

Создадим компактную таблицу пользователей:

```sql
CREATE DATABASE IF NOT EXISTS index_demo;
USE index_demo;

DROP TABLE IF EXISTS users;

CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(255) NOT NULL,
  first_name VARCHAR(100) NOT NULL,
  city VARCHAR(100) NOT NULL,
  age TINYINT UNSIGNED NOT NULL
);

INSERT INTO users (email, first_name, city, age) VALUES
('anna@example.com', 'Анна', 'Москва', 19),
('ivan@example.com', 'Иван', 'Казань', 20),
('olga@example.com', 'Ольга', 'Москва', 18),
('petr@example.com', 'Петр', 'Томск', 21),
('maria@example.com', 'Мария', 'Казань', 19),
('sergey@example.com', 'Сергей', 'Пермь', 20),
('nina@example.com', 'Нина', 'Москва', 22);
```

---

## Добавление индекса

### Неуникальный индекс

```sql
ALTER TABLE users
ADD INDEX idx_users_first_name (first_name);
```

Индекс поможет при частом поиске по `first_name`.

### Уникальный индекс

```sql
ALTER TABLE users
ADD UNIQUE INDEX uq_users_email (email);
```

Теперь значения `email` не могут повторяться.

Если попытаться вставить дубликат email, MySQL вернет ошибку.

---

## Как посмотреть индексы

```sql
SHOW INDEX FROM users;
```

Эта команда показывает:

- имя индекса;
- по какому столбцу он построен;
- уникальный индекс или нет.

---

## Как удалить индекс

```sql
ALTER TABLE users
DROP INDEX idx_users_first_name;
```

Удалять индексы полезно, если они больше не нужны и только замедляют запись.

---

## Как быстро проверить, что индекс используется

Для базовой проверки используется `EXPLAIN`.

```sql
EXPLAIN
SELECT *
FROM users
WHERE first_name = 'Анна';
```

Для старта достаточно смотреть три поля:

- `type` - способ доступа к данным;
- `key` - какой индекс выбрал MySQL;
- `rows` - сколько строк MySQL ожидает прочитать.

::: tip
Если после создания индекса в `key` появилось имя этого индекса, обычно это хороший признак, что индекс задействован.
:::

---

## В чем отличие от SQLite

Синтаксис создания индекса похож, но поведение СУБД не одинаковое.

| Вопрос | MySQL | SQLite |
| --- | --- | --- |
| Архитектура | серверная СУБД | встраиваемая СУБД (файл) |
| Проверка плана | `EXPLAIN` | `EXPLAIN QUERY PLAN` |
| Основной контекст использования | многопользовательские серверные системы | локальные/встраиваемые решения |

Практический вывод:

- одинаковый SQL не гарантирует одинаковую скорость;
- после переноса запроса между SQLite и MySQL план нужно проверять заново.

---

## Частые ошибки при работе с индексами

- Добавлять индексы «на все столбцы подряд».
- Не проверять результат через `EXPLAIN`.
- Индексировать поля, по которым почти нет фильтрации.
- Забывать, что каждый индекс замедляет `INSERT` и `UPDATE`.

---

## Практические рекомендации

- Добавляйте индекс только под реальные частые запросы.
- Начинайте с полей из `WHERE`, `JOIN`, `ORDER BY`.
- Для уникальных данных (`email`, `guid`) используйте `UNIQUE`.
- После добавления индекса всегда делайте быструю проверку `EXPLAIN`.

---

## Самопроверка

::: quiz source=./includes/quiz-20.yaml
:::

## Практические задания

### Задание 1. Неуникальный индекс

::: tabs

@tab Условие

В базе `index_demo` добавьте индекс на `city`, затем проверьте план запроса:

```sql
SELECT *
FROM users
WHERE city = 'Москва';
```

@tab Решение

```sql
ALTER TABLE users
ADD INDEX idx_users_city (city);

EXPLAIN
SELECT *
FROM users
WHERE city = 'Москва';
```

:::

### Задание 2. Уникальный индекс

::: tabs

@tab Условие

Добавьте уникальный индекс на `email`, затем попробуйте вставить дубликат `email`.

@tab Решение

```sql
ALTER TABLE users
ADD UNIQUE INDEX uq_users_email (email);

INSERT INTO users (email, first_name, city, age)
VALUES ('anna@example.com', 'Анна2', 'Москва', 19);
```

Ожидаемый результат: ошибка из-за нарушения уникальности.

:::

### Задание 3. Просмотр и удаление индекса

::: tabs

@tab Условие

1. Посмотрите список индексов таблицы `users`.
2. Удалите индекс `idx_users_city`.
3. Снова посмотрите список индексов.

@tab Решение

```sql
SHOW INDEX FROM users;

ALTER TABLE users
DROP INDEX idx_users_city;

SHOW INDEX FROM users;
```

:::

## Полезные ссылки

- [MySQL 8.4 Reference Manual - Optimization and Indexes](https://dev.mysql.com/doc/refman/8.4/en/optimization.html)
- [MySQL 8.4 Reference Manual - EXPLAIN Statement](https://dev.mysql.com/doc/refman/8.4/en/explain.html)
